#!/bin/bash

#------------------------------------------------------------
# Usage
#------------------------------------------------------------

PROGRAM=$(basename $0)
read -r -d '' USAGE <<HEREDOC
Usage: $PROGRAM [options] <mpet_read1.fq> <mpet_read2.fq> \\
   <pet_read1.fq> <pet_read2.fq> [<pet_read1.fq> <pet_read2.fq>]...

Do a targeted assembly of MPET fragment(s) using ABySS. The
input files are MPET and PET sequencing reads which must be provided
as FASTA/FASTQ pairs.  The input files may be gzipped.

The MPET read pairs act as anchors for recruiting PET reads for
the assembly. As such, the coverage depth of the MPET pairs is not
important to ensure a good outcome.  The most significant factors
affecting the results are the the length of the MPET reads, the
sequencing error rate of the MPET reads, and the coverage depth
of the PET reads.

It is recommended to trim the adapter sequences from the MPET
reads before running this script.

Options:
    -a FILE   align reads to reference genome FILE after
              each iteration (for debugging) [disabled]
    -C        don't clean up intermediate files (for debugging)
    -h        show this help message
    -j N      threads [1]
    -l N      min match length for recruiting seed PETs using
              seed MPETs as bait; only one of the PET reads
              of each pair needs to match [30]
    -L N      min match length for recruiting PETs using
              previously recruited PETs as bait; both reads
              of a PET pair must match with at least this
              length [15]
    -k N      k-mer size for ABySS contig assembly [50]
    -K N      k-mer size for read overlap detection [25]
    -m N      max iterations for recruiting PET reads [10]
    -n N      max k-mers to recruit in total [25000]
    -o FILE   output file prefix ['kollector']
    -r FILE   Bloom filter containing repeat k-mers for
              exclusion from scoring calculations; must match
              k-mer size selected with -K opt [disabled]
    -R FILE   write resource usage to FILE (wall clock time,
              peak disk space) [disabled]
HEREDOC

set -eu -o pipefail

#------------------------------------------------------------
# Parse command line opts
#------------------------------------------------------------

# default values for options
max_iterations=15
j=1
k=50
K=25
l=30
L=15
prefix=kollect
max_kmers=25000
help=0
clean=1

# parse command line options
while getopts :a:d:hCj:k:K:l:L:m:n:o:r:R: opt; do
	case $opt in
		a) ref=$OPTARG;;
		C) clean=0;;
		d) mpet_dist=$OPTARG;;
		h) help=1;;
		j) j=$OPTARG;;
		k) k=$OPTARG;;
		K) K=$OPTARG;;
		l) l=$OPTARG;;
		L) L=$OPTARG;;
		m) max_iterations=$OPTARG;;
		n) max_kmers=$OPTARG;;
		o) prefix=$OPTARG;;
		r) r=$OPTARG;;
		R) R=$OPTARG;;
		\?) echo "$PROGRAM: invalid option: $OPTARG"; exit 1;;
	esac
done
shift $((OPTIND-1))

# -h for help message
if [ $help -ne 0 ]; then
	echo "$USAGE"
	exit 0;
fi

# we expect 4 or more file arguments, and
# the number of file arguments must be a
# multiple of 2.
if [ $# -lt 4 -o $(($# % 2)) -ne 0 ]; then
	echo "$USAGE" >&2
	exit 1;
fi

mpet1=$1; shift;
mpet2=$1; shift;
num_pet_libs=$(($# / 2))
all_pet="$@"
for lib in $(seq 1 $num_pet_libs); do
	pet_read1[$lib]=$1; shift;
	pet_read2[$lib]=$1; shift;
done

#------------------------------------------------------------
# Helper functions
#------------------------------------------------------------

# print progress message
function heading() {
	echo '-----------------------------------------'
	echo -e "$@"
	echo '-----------------------------------------'
}

function update_peak_disk_usage() {
	disk_usage=$(du -sb | cut -f1)
	if [ $disk_usage -gt $peak_disk_usage ]; then
		peak_disk_usage=$disk_usage
	fi
}

#------------------------------------------------------------
# Start up
#------------------------------------------------------------

heading "Recruiting a maximum of $max_kmers k-mers"
start_time=$(date +%s)
peak_disk_usage=0

#------------------------------------------------------------
# Tag seed MPET/PET read pairs
#------------------------------------------------------------

# align seed MPETs
if [ "${ref+defined}" = 'defined' ]; then
	heading "Aligning seed MPET reads..."
	kollector-align.mk query="$mpet1 $mpet2" ref=$ref j=$j name=$prefix.seed_mp
fi

# build seed FASTA file for recruiting PET reads
heading 'Building seed FASTA file...'
kollector-tag.mk name=$prefix mp="$mpet1 $mpet2" pe="$all_pet" \
	n=$max_kmers j=$j s=$l k=$K ${r+subtract=$r}

# align seed MPETs and PETs
if [ "${ref+defined}" = 'defined' ]; then
	heading "Aligning seed MPET and PET reads..."
	kollector-align.mk query=$prefix.seed.fa ref=$ref j=$j name=$prefix.seed.fa
fi

update_peak_disk_usage

#------------------------------------------------------------
# Iteratively recruit PET read pairs from seed PET/MPET
#------------------------------------------------------------

for i in $(seq 1 $max_iterations); do

	prev_i=$(($i-1))
	heading "Recruiting PET reads (iteration $i)..."

	for lib in $(seq 1 $num_pet_libs); do

		prev_lib=$(($lib-1))
		read1="${pet_read1[$lib]}"
		read2="${pet_read2[$lib]}"
		heading "Recruiting reads from PET library $lib\n($read1, $read2)"

		# select seed FASTA file for next round of PET recruitment
		if [ $i -eq 1 -a $lib -eq 1 ]; then
			seed=$prefix.seed.fa
		elif [ $lib -eq 1 ]; then
			seed=$prefix-$prev_i.all-pet.fa
		else
			seed=$prefix-$i.all-pet.fa
		fi

		# recruit PETs with paired overlap to previously recruited PETs
		kollector-recruit.mk name=$prefix-$i.pet-$lib seed=$seed \
			pe="$read1 $read2" s=$L n=$max_kmers j=$j k=$K ${r+subtract=$r}

		# aggregate reads recruited from each PET lib
		# (seed file for next iteration)
		if [ $lib -eq 1 ]; then
			zcat $prefix-$i.pet-$lib.fa.gz > $prefix-$i.all-pet.fa
		else
			zcat $prefix-$i.pet-$lib.fa.gz >> $prefix-$i.all-pet.fa
		fi

		update_peak_disk_usage

		# delete files from prev iteration
		if [ $clean -eq 1 ]; then
			if [ $i -eq 1 ]; then
				kollector-tag.mk name=$prefix clean
			else
				kollector-recruit.mk name=$prefix-$prev_i.pet-$lib clean
			fi
		fi

		# align all recruited PETs to reference genome (debugging)
		if [ "${ref+defined}" = 'defined' ]; then
			heading "Aligning all PET reads recruited so far..."
			kollector-align.mk query=$prefix-$i.pet-$lib.fa.gz ref=$ref \
				j=$j name=$prefix-$i.pet-$lib
		fi

		update_peak_disk_usage

		# check for stopping condition
		kmers=$(awk -F= '$1=="num_entries" {sum+=$2} END {print sum}' \
			$prefix-$i.pet-$lib.txt)
		heading "Recruited $kmers distinct k-mers so far."
		if [ $kmers -ge $max_kmers ]; then
			heading "Stopping. Recruited k-mers ($kmers) exceeded limit ($max_kmers)"
			break
		fi

	done # for each PET library

done # for each iteration

# clean up last iteration
if [ $clean -eq 1 ]; then
	rm -f $prefix-$i.all-pet.fa
	for lib in $(seq 1 $num_pet_libs); do
		mv $prefix-$i.pet-$lib.fa.gz $prefix.pet-$lib.fa.gz
		kollector-recruit.mk name=$prefix-$i.pet-$lib clean
	done
else
	for lib in $(seq 1 $num_pet_libs); do
		ln -sf $prefix-$i.pet-$lib.fa.gz $prefix.pet-$lib.fa.gz
	done
fi

#------------------------------------------------------------
# Contig assembly with ABySS
#------------------------------------------------------------

heading "Running ABySS contig assembly..."

# set input sequence library params for ABySS
for i in $(seq 1 $num_pet_libs); do
	if [ $i -eq 1 ]; then
		export lib="pet$i"
	else
		export lib="$lib pet$i"
	fi
	abs_path=$(readlink -f $prefix.pet-$i.fa.gz)
	eval "export pet$i=$abs_path"
done

# run ABySS
abyss_dir=$prefix.abyss
mkdir -p $abyss_dir
abyss-pe -C $abyss_dir k=$k name=$prefix contigs

update_peak_disk_usage

# clean up assembly
abyss_contigs=$prefix.abyss-contigs.fa.gz
if [ $clean -eq 1 ]; then
	for lib in $(seq 1 $num_pet_libs); do
		rm -f $prefix.pet-$lib.fa.gz
	done
	gzip -c $abyss_dir/$prefix-6.fa > $abyss_contigs
	rm -rf $abyss_dir
else
	gzip -f $abyss_dir/$prefix-6.fa
	ln -sf $abyss_dir/$prefix-6.fa.gz $abyss_contigs
fi

#------------------------------------------------------------
# Extract successfully assembled MPET frags
#------------------------------------------------------------

heading "Extracting successfully assembled MPET fragments from ABySS contigs..."

kollector-extract.mk name=$prefix-assembly contigs=$abyss_contigs \
	mpet="$mpet1 $mpet2" j=$j

update_peak_disk_usage

# clean up from extraction work
if [ $clean -eq 1 ]; then
	rm -f $abyss_contigs
	kollector-extract.mk name=$prefix-assembly clean
fi

#------------------------------------------------------------
# Report resource usage
#------------------------------------------------------------

stop_time=$(date +%s)
wallclock_time=$(($stop_time - $start_time))

msg="Resource usage:"
msg="$msg\n\tWallclock time: $wallclock_time sec"
msg="$msg\n\tPeak disk usage: $peak_disk_usage bytes"
heading $msg

if [ "${R+defined}" = 'defined' ]; then
	printf 'wallclock_time\tpeak_disk_usage\n' > $R
	printf '%d\t%d\n' $wallclock_time $peak_disk_usage >> $R
fi
