#!/bin/bash

#------------------------------------------------------------
# Usage
#------------------------------------------------------------

PROGRAM=$(basename $0)
read -r -d '' USAGE <<HEREDOC
Usage: $PROGRAM [options] <mpet_read1.fq> <mpet_read2.fq> \\
   <pet_read1.fq> <pet_read2.fq> [<pet_read1.fq> <pet_read2.fq>]...

Description:

Do a targeted assembly of MPET fragment(s) using ABySS. The
input files are MPET and PET sequencing reads which must be provided
as FASTA/FASTQ pairs.  The input files may be gzipped.

The MPET read pairs act as anchors for recruiting PET reads for
the assembly. As such, the coverage depth of the MPET pairs is not
important to ensure a good outcome.  The most significant factors
affecting the results are the the length of the MPET reads, the
sequencing error rate of the MPET reads, and the coverage depth
of the PET reads.

It is recommended to trim the adapter sequences from the MPET
reads before running this script.

Options:

    -a        align reads to reference genome (specified by -g)
              after each iteration (for debugging) [disabled]
    -A STR    specify custom abyss-pe args ['contigs']
    -C        don't clean up intermediate files (for debugging)
    -e        evaluate assembled MPET fragments by aligning
              to the reference sequence (specified by -g)
              [disabled]
    -g FILE   use FILE for the reference genome (required if
              using -a or -e options) [disabled]
    -h        show this help message
    -j N      threads [1]
    -l N      min match length for recruiting seed PETs using
              seed MPETs as bait; only one of the PET reads
              of each pair needs to match [30]
    -L N      min match length for recruiting PETs using
              previously recruited PETs as bait; both reads
              of a PET pair must match with at least this
              length [15]
    -k N      k-mer size for ABySS contig assembly [50]
    -K N      k-mer size for read overlap detection [25]
    -m N      max iterations for recruiting PET reads [10]
    -n N      max k-mers to recruit in total [25000]
    -o FILE   output file prefix ['kollector']
    -r FILE   Bloom filter containing repeat k-mers for
              exclusion from scoring calculations; must match
              k-mer size selected with -K opt [disabled]
    -R FILE   print summary report to FILE (see description
              of fields below) [disabled]

Summary report:

    (1) 'mpet': num input MPET pairs
    (2) 'mpet_assembled': num MPET frags assembled
    (3) 'percent_mpet_assembled': percent MPET frags assembled
    (4) 'kmers_recruited': num distinct k-mers recruited
    (5) 'N50': N50 assembly metric
    (6) 'sum': total number of bases assembled
    (7) 'wallclock_time': running time in seconds
    (8) 'peak_disk_usage': peak disk space usage in bytes
HEREDOC

set -eu -o pipefail

#------------------------------------------------------------
# Parse command line opts
#------------------------------------------------------------

# default values for options
align=0
evaluate=0
j=1
k=50
K=25
l=30
L=15
max_iterations=10
prefix=kollect
max_kmers=25000
help=0
clean=1
R=/dev/null
abyss_opt='contigs'

# parse command line options
while getopts :aA:d:eg:hCj:k:K:l:L:m:n:o:r:R: opt; do
	case $opt in
		a) align=1;;
		A) abyss_opt="$OPTARG";;
		C) clean=0;;
		d) mpet_dist=$OPTARG;;
		e) evaluate=1;;
		g) ref=$OPTARG;;
		h) help=1;;
		j) j=$OPTARG;;
		k) k=$OPTARG;;
		K) K=$OPTARG;;
		l) l=$OPTARG;;
		L) L=$OPTARG;;
		m) max_iterations=$OPTARG;;
		n) max_kmers=$OPTARG;;
		o) prefix=$OPTARG;;
		r) r=$OPTARG;;
		R) R=$OPTARG;;
		\?) echo "$PROGRAM: invalid option: $OPTARG"; exit 1;;
	esac
done
shift $((OPTIND-1))

# -h for help message
if [ $help -ne 0 ]; then
	echo "$USAGE"
	exit 0;
fi

# we expect 4 or more file arguments, and
# the number of file arguments must be a
# multiple of 2.
if [ $# -lt 4 -o $(($# % 2)) -ne 0 ]; then
    echo "Error: number of file args must be >= 4 and a multiple of 2" >&2
	echo "$USAGE" >&2
	exit 1
fi

# -a and -e also require a reference genome (with -g)
if [ $align -ne 0 -o $evaluate -ne 0 ] && \
	[ ${ref:-undefined} -eq 'undefined' ]; then
	echo "Error: must provide a reference genome with -g when using -a or -e" \
		>&2
	echo "$USAGE" >&2
	exit 1
fi

mpet1=$1; shift;
mpet2=$1; shift;
num_pet_libs=$(($# / 2))
all_pet="$@"
for lib in $(seq 1 $num_pet_libs); do
	pet_read1[$lib]=$1; shift;
	pet_read2[$lib]=$1; shift;
done

#------------------------------------------------------------
# Helper functions
#------------------------------------------------------------

# print progress message
function heading() {
	echo '-----------------------------------------'
	echo -e "$@"
	echo '-----------------------------------------'
}

# track peak disk space usage
function update_peak_disk_usage() {
	disk_usage=$(du -sb | cut -f1)
	if [ $disk_usage -gt $peak_disk_usage ]; then
		peak_disk_usage=$disk_usage
	fi
}

#------------------------------------------------------------
# Start up
#------------------------------------------------------------

heading "Recruiting a maximum of $max_kmers k-mers"
start_time=$(date +%s)
peak_disk_usage=0

#------------------------------------------------------------
# Tag seed MPET/PET read pairs
#------------------------------------------------------------

# align seed MPETs
if [ $align -ne 0 ]; then
	heading "Aligning seed MPET reads..."
	kollector-align.mk query="$mpet1 $mpet2" ref=$ref j=$j name=$prefix.seed_mp
fi

# build seed FASTA file for recruiting PET reads
heading 'Building seed FASTA file...'
kollector-tag.mk name=$prefix mp="$mpet1 $mpet2" pe="$all_pet" \
	n=$max_kmers j=$j s=$l k=$K ${r+subtract=$r}

# align seed MPETs and PETs
if [ $align -ne 0 ]; then
	heading "Aligning seed MPET and PET reads..."
	kollector-align.mk query=$prefix.seed.fa ref=$ref j=$j name=$prefix.seed.fa
fi

update_peak_disk_usage

#------------------------------------------------------------
# Iteratively recruit PET read pairs from seed PET/MPET
#------------------------------------------------------------

for i in $(seq 1 $max_iterations); do

	prev_i=$(($i-1))
	heading "Recruiting PET reads (iteration $i)..."

	for lib in $(seq 1 $num_pet_libs); do

		prev_lib=$(($lib-1))
		read1="${pet_read1[$lib]}"
		read2="${pet_read2[$lib]}"
		heading "Recruiting reads from PET library $lib\n($read1, $read2)"

		# select seed FASTA file for next round of PET recruitment
		if [ $i -eq 1 -a $lib -eq 1 ]; then
			seed=$prefix.seed.fa
		elif [ $lib -eq 1 ]; then
			seed=$prefix-$prev_i.all-pet.fa
		else
			seed=$prefix-$i.all-pet.fa
		fi

		# recruit PETs with paired overlap to previously recruited PETs
		kollector-recruit.mk name=$prefix-$i.pet-$lib seed=$seed \
			pe="$read1 $read2" s=$L n=$max_kmers j=$j k=$K ${r+subtract=$r}

		# aggregate reads recruited from each PET lib
		# (seed file for next iteration)
		if [ $lib -eq 1 ]; then
			zcat $prefix-$i.pet-$lib.fa.gz > $prefix-$i.all-pet.fa
		else
			zcat $prefix-$i.pet-$lib.fa.gz >> $prefix-$i.all-pet.fa
		fi

		update_peak_disk_usage

		# delete files from prev iteration
		if [ $clean -eq 1 ]; then
			if [ $i -eq 1 ]; then
				kollector-tag.mk name=$prefix clean
			else
				kollector-recruit.mk name=$prefix-$prev_i.pet-$lib clean
			fi
		fi

		# align all recruited PETs to reference genome (debugging)
		if [ $align -ne 0 ]; then
			heading "Aligning all PET reads recruited so far..."
			kollector-align.mk query=$prefix-$i.pet-$lib.fa.gz ref=$ref \
				j=$j name=$prefix-$i.pet-$lib
		fi

		update_peak_disk_usage

		# check for stopping condition
		kmers=$(awk -F= '$1=="num_entries" {sum+=$2} END {print sum}' \
			$prefix-$i.pet-$lib.txt)
		heading "Recruited $kmers distinct k-mers so far."
		if [ $kmers -ge $max_kmers ]; then
			heading "Stopping. Recruited k-mers ($kmers) exceeded limit ($max_kmers)"
			# break out of both inner and outer loop
			break 2
		fi

	done # for each PET library

done # for each iteration

# clean up last iteration
if [ $clean -eq 1 ]; then
	rm -f $prefix-$i.all-pet.fa
	for lib in $(seq 1 $num_pet_libs); do
		mv $prefix-$i.pet-$lib.fa.gz $prefix.pet-$lib.fa.gz
		kollector-recruit.mk name=$prefix-$i.pet-$lib clean
	done
else
	for lib in $(seq 1 $num_pet_libs); do
		ln -sf $prefix-$i.pet-$lib.fa.gz $prefix.pet-$lib.fa.gz
	done
fi

#------------------------------------------------------------
# Contig assembly with ABySS
#------------------------------------------------------------

heading "Running ABySS contig assembly..."

# set input sequence library params for ABySS
for i in $(seq 1 $num_pet_libs); do
	if [ $i -eq 1 ]; then
		export lib="pet$i"
	else
		export lib="$lib pet$i"
	fi
	abs_path=$(readlink -f $prefix.pet-$i.fa.gz)
	eval "export pet$i=$abs_path"
done

# run ABySS
abyss_dir=$prefix.abyss
mkdir -p $abyss_dir
abyss-pe -C $abyss_dir k=$k name=$prefix $abyss_opt

# Select most recently created FASTA in ABySS output dir.
# This allows assembly up to different stages with -A opt.
abyss_fa=$(ls -1t $abyss_dir/$prefix-?.fa | head -1)

update_peak_disk_usage

# clean up assembly
abyss_contigs=$prefix.abyss-contigs.fa.gz
if [ $clean -eq 1 ]; then
	for lib in $(seq 1 $num_pet_libs); do
		rm -f $prefix.pet-$lib.fa.gz
	done
	gzip -c $abyss_fa > $abyss_contigs
	rm -rf $abyss_dir
else
	gzip -c $abyss_fa > $abyss_contigs
fi

#------------------------------------------------------------
# Extract successfully assembled MPET frags
#------------------------------------------------------------

heading "Extracting successfully assembled MPET fragments from ABySS contigs..."

kollector-extract.mk name=$prefix-assembly contigs=$abyss_contigs \
	mpet="$mpet1 $mpet2" j=$j

update_peak_disk_usage

# clean up from extraction work
if [ $clean -eq 1 ]; then
	rm -f $abyss_contigs
	kollector-extract.mk name=$prefix-assembly clean
fi

assembly=$prefix-assembly.fa.gz

#------------------------------------------------------------
# Calculate edit distances and detect misassemblies
# by aligning to the reference
#------------------------------------------------------------

if [ $evaluate -ne 0 ]; then
	kollector-eval.mk ref=$ref assembly=$assembly name=$prefix
fi

#------------------------------------------------------------
# Print summary report
#------------------------------------------------------------

heading "Results:"

mpet=$(bioawk -c fastx 'END {print NR}' $mpet1)
mpet_assembled=$(zcat $assembly | { egrep -c '^>' || true; } )
percent_mpet_assembled=$(echo "scale=2; $mpet_assembled/$mpet" | bc)
kmers_recruited=$kmers
N50=$(abyss-fac $assembly | sed 1d | cut -f6)
sum=$(abyss-fac $assembly | sed 1d | cut -f10)
stop_time=$(date +%s)
wallclock_time=$(($stop_time - $start_time))

echo -e \
	mpet \
	mpet_assembled \
	percent_mpet_assembled \
	kmers_recruited \
	N50 \
	sum \
	wallclock_time \
	peak_disk_usage "\n" \
	$mpet \
	$mpet_assembled \
	$percent_mpet_assembled \
	$kmers_recruited \
	$N50 \
	$sum \
	$wallclock_time \
	$peak_disk_usage | \
		sed -r 's/\s+/\t/g' | \
		tee $R | \
		column -t
